<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: components/TaggingTool/Tag/Multi/multiWord.jsx</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: components/TaggingTool/Tag/Multi/multiWord.jsx</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import React, { Component } from "react";
import "../TagComponents/tag.css";
import TagButton from "../TagComponents/tagButton";
import Note from "../TagComponents/note";
import { updateMultiTokens, updateVocab } from "./multiTokensAction";
import { connect } from "react-redux";
import { createSelector } from "reselect";
import List from "../TagComponents/list";
import text from "../../../../assets/language/en.js";
import { ProgressBar } from 'react-bootstrap';
import { getCompleteness } from '../../Report/reportAction';
import Alert from "../../../CommonComponents/Alert/alert";
import { exportOutput } from "../../Export/exportAction";
import Button from 'react-bootstrap/Button'

/**
 * Component for multi word page.
 * 
 * @component
 */
class MultiWord extends Component {

  /** 
   * @constructor
   */
  constructor(props) {
    super(props);
    this.state = {
      showModal: false,
      showNoClassificationModal: false
    }
  }

  /**
   * A react lifecycle method called when the component did mount.
   * It inits the multi word tokens with the appropriate alias and also
   * get the completeness of the project to update the progress bar
   */
  componentDidMount() {
    // this.props.onExportOutput();
    this.initTokenWithSynonymAlias(this.props.match.params.id);
    this.props.onGetCompleteness();
  }

  /**
 * A react lifecycle method to determine whether or not the component should update
 * @param {props} nextProps the new props of the application
 * @returns true if multi tokens props changed or if the search modal
 * display has changed
 */
  shouldComponentUpdate(nextProps) {
    return nextProps.multiTokens !== this.props.multiTokens ||
      nextProps.match.params.id !== this.props.match.params.id ||
      nextProps.showModal !== this.state.showModal
      ? true
      : false;
  }


  /**
 * A react lifecycle method called when the component did update.
 * Checks whether the props match.id changed and init tokens 
 * with appropriate alias, get the completeness of the project,
 * and update the vocab of multi grams.
 */
  componentDidUpdate(prevProps) {
    if (prevProps.match.params.id !== this.props.match.params.id) {
      this.initTokenWithSynonymAlias(this.props.match.params.id);
      this.props.onUpdateVocab(
        this.props.multiTokens[prevProps.match.params.id]
      );
      this.props.onGetCompleteness();
    }
  }

  /**
   * The render function.
   */
  render() {
    return (
      &lt;div className="tag-container">
        {this.state.showNoClassificationModal &amp;&amp; (
          &lt;Alert
            alertHeader={text.taggingTool.alerts.tag.noClassificationHeader}
            alertMessage={text.taggingTool.alerts.tag.noClassificationMessage}
            styleColor="alert alert-danger"
            onDelete={this.handleHideNoClassificationAlert}
          />
        )}
        &lt;div className="tag-section">
          &lt;div className="token-tagging-section">
            &lt;ProgressBar
              animated
              striped
              variant="success"
              now={
                this.props.report.total === this.props.report.empty
                  ? 0
                  : ((this.props.report.total -
                    this.props.report.empty -
                    this.props.report.complete) /
                    this.props.report.total) *
                  100
              }
              label={
                this.props.report.total === this.props.report.empty
                  ? 0
                  : (
                    ((this.props.report.total -
                      this.props.report.empty -
                      this.props.report.complete) /
                      this.props.report.total) *
                    100
                  ).toFixed(2) + " % Complete"
              }
              key={1}
            />
            &lt;br />
            &lt;h4>{this.props.multiTokens[parseInt(this.props.match.params.id)].label}&lt;/h4>
            &lt;div>Alias&lt;/div>
            &lt;div className="alias">
              &lt;div>
                &lt;input
                  type="text"
                  className="form-control"
                  placeholder="Enter alias"
                  value={
                    this.props.multiTokens[parseInt(this.props.match.params.id)]
                      .alias
                  }
                  onChange={this.updateValue}
                />
              &lt;/div>
            &lt;/div>
            &lt;br />
            &lt;div>Hybrid Classification&lt;/div>
            &lt;div className="classification-tags">
              &lt;br />
              {this.props.classification.rules.map((obj, i) => (
                &lt;TagButton
                  key={i}
                  value={obj.label}
                  shortkey={obj.shortkey}
                  showTooltipIcon={false}
                  tooltip={""}
                  color={obj.color}
                  style={{ borderColor: obj.color }}
                  onClick={this.handleAddClassification}
                />
              ))}
            &lt;/div>
            &lt;br />
            &lt;div>Classification&lt;/div>
            &lt;div className="classification-tags">
              &lt;br />
              {this.props.classification.types.map((obj, i) => (
                &lt;TagButton
                  key={i}
                  value={obj.label}
                  shortkey={obj.shortkey}
                  showTooltipIcon={false}
                  showCloseIcon={false}
                  tooltip={""}
                  color={obj.color}
                  style={{ borderColor: obj.color }}
                  onClick={this.handleAddClassification}
                />
              ))}
            &lt;/div>
            &lt;div className="buttons">
              {window.multiTokensHistory.length > 0 &amp;&amp;
                &lt;Button
                  size="sm"
                  onClick={this.handleBack}
                  className="back-button"
                  label="Back to Single Word"
                  variant="outline-primary"
                >
                  &lt;i className="fas fa-arrow-left">&lt;/i>&amp;nbsp;&amp;nbsp;Back to Single Word
                &lt;/Button>}
              &lt;Button
                size="sm"
                onClick={this.handleContinue}
                variant="primary"
                label="Continue"
                className="btn-continue">
                Continue&amp;nbsp;&amp;nbsp;&lt;i className="fas fa-arrow-right">&lt;/i>
              &lt;/Button>
            &lt;/div>
          &lt;/div>
          &lt;div className="token-view">
            &lt;h4>Summary&lt;/h4>
            &lt;input
              type="text"
              className="form-control"
              value={
                this.props.multiTokens[
                  parseInt(this.props.match.params.id)
                ].alias
              }
              readOnly
            />
            {this.props.multiTokens[parseInt(this.props.match.params.id)]
              .classification.label ? &lt;div
                className="badge"
                style={{
                  borderColor: this.props.multiTokens[
                    parseInt(this.props.match.params.id)
                  ].classification.color
                }}
              >
                {
                  this.props.multiTokens[parseInt(this.props.match.params.id)]
                    .classification.value
                }
              &lt;/div> : &lt;div
                className="badge-no-classification"
              >
                No classification
                &lt;/div>}
            &lt;br />
            &lt;div>Composed by&lt;/div>
            {this.props.multiTokens[parseInt(this.props.match.params.id)].composedWith.map((obj, i) => (
              &lt;Button
                variant="outline-dark"
                className="composedwith-button"
                key={i}
                onClick={() => this.handleClickOnSingleToken(obj)}
              >{obj.label}&lt;/Button>
            ))}
            &lt;Note
              showNote={
                this.props.multiTokens[parseInt(this.props.match.params.id)]
                  .note.showNote
              }
              value={
                this.props.multiTokens[parseInt(this.props.match.params.id)]
                  .note.value
              }
              onClick={this.handleToggle}
              onAdd={this.handleAddNote}
              onChangeNote={this.handleChangeNote}
              disabled={false}
              onEdit={this.handleEditNote}
            />
          &lt;/div>
          &lt;div className="side-bar">
            &lt;i
              className="far fa-window-maximize"
              onClick={this.handleShowModal}
            />
          &lt;/div>
          &lt;List
            showModal={this.state.showModal}
            onDelete={this.handleDeleteModal}
            onClick={this.handleClickList}
            list={this.props.multiTokens}
          />
        &lt;/div>
      &lt;/div>
    );
  }

  /**
   * function called when clicking on the back to single Token button
   * it reset the history of multitokens to empty and then redirect to 
   * singleTokens 
   * @function
   */
  handleBack = () => {
    const backToSingleToken = window.multiTokensHistory[window.multiTokensHistory.length - 1];
    window.multiTokensHistory = [];
    this.props.history.push(backToSingleToken);
  }

  /**
   * function when clicked on a single token in the composed by section
   * it update the singleToken History with current path in the application
   * and redirect to the single token clicked on
   * @param {token} token The single word token clicked on Back to single token button
   * @function
   */
  handleClickOnSingleToken = token => {
    window.singleTokenHistory.push("/taggingTool/tag/multi/" + this.props.multiTokens[parseInt(this.props.match.params.id)].index);
    this.props.history.push("/taggingTool/tag/single/" + token.index);
  }

  /**
   * function called when clicking on a multi word token 
   * It hides the search modal and redirect to the multi token clicked
   * @param {token} token the token clicked on in the search modal
   * @function
   */
  handleClickList = token => {
    this.handleDeleteModal();
    this.props.history.push("/taggingTool/tag/multi/" + token.index);
  };

  /**
   * function called when clicking on the continue button
   * it checks if a classification has been selected and then redirect 
   * to the next multi token in the list ranked by tf-idf
   * @function
   */
  handleContinue = () => {
    if (this.props.multiTokens[parseInt(this.props.match.params.id)].classification.color === "") {
      this.setState({ showNoClassificationModal: true });
      return null;
    } else {
      this.setState({ showNoClassificationModal: false });
    }
    var index = [...this.props.multiTokens].findIndex(
      element => element.classification.color === ""
    );
    if (index === -1) {
      this.props.history.push("/taggingTool/report");
    } else {
      this.props.history.push("/taggingTool/tag/multi/" + index);
    }
  };

  /**
   * function that hide the alert message when trying to continue
   * without classification selected
   * @function
   */
  handleHideNoClassificationAlert = () => {
    this.setState({ showNoClassificationModal: false });
  }

  /**
   * function to hide modal of search among between multi words
   * @function
   */
  handleDeleteModal = () => {
    this.setState({ showModal: false });
  };

  /**
   * function to show the modal of search among all the multi words 
   * @function
   */
  handleShowModal = () => {
    this.setState({ showModal: true });
  };

  /** 
   * function to update the the value of the alias of the current multiToken
   * @param {event} event the event generated when typing in the alias form field
   * @function
   */
  updateValue = event => {
    var tokens = [...this.props.multiTokens];
    var token = {
      ...this.props.multiTokens[parseInt(this.props.match.params.id)]
    };
    token.alias = event.target.value;
    tokens[parseInt(this.props.match.params.id)] = token;
    this.props.onUpdateMultiTokens(tokens);
  };

  /**
   * function to add a classification to the current multi word
   * @param {classificationTag} classificationTag The classification of the multi word
   * @function
   */
  handleAddClassification = classificationTag => {
    var tokens = [...this.props.multiTokens];
    var token = {
      ...this.props.multiTokens[parseInt(this.props.match.params.id)]
    };
    token.classification.color = classificationTag.color;
    token.classification.label = classificationTag.shortkey;
    token.classification.value = classificationTag.value;
    tokens[parseInt(this.props.match.params.id)] = token;
    this.props.onUpdateMultiTokens(tokens);
  };

  /**
   * function to toggle the text area of the note of the current multi word
   * @function
   */
  handleToggle = () => {
    var tokens = [...this.props.multiTokens];
    var token = {
      ...this.props.multiTokens[parseInt(this.props.match.params.id)]
    };
    token.note.showNote = !token.note.showNote;
    tokens[parseInt(this.props.match.params.id)] = token;
    this.props.onUpdateMultiTokens(tokens);
  };

  /**
   * function to change the texte of the note 
   * @param {event} event event generated automatically when typing in the typing area
   * @function
   */
  handleChangeNote = event => {
    var tokens = [...this.props.multiTokens];
    var token = {
      ...this.props.multiTokens[parseInt(this.props.match.params.id)]
    };
    token.note.value = event.target.value;
    tokens[parseInt(this.props.match.params.id)] = token;
    this.props.onUpdateMultiTokens(tokens);
  };
  handleAddNote = () => { };
  handleEditNote = () => { };

  /**
   * function to init all the multitokens with the appropriate alias,
   * basically their label, and also set the single tokens which composed the
   * current multi word  
   * @function
   */
  initTokenWithSynonymAlias(index) {
    var tokens = [...this.props.multiTokens];
    var token = { ...this.props.multiTokens[index] };

    if (token.synonyms.length &lt; 1) {
      // var synonyms = this.computeSynonyms(token.label);
      // token.synonyms = synonyms;
      tokens[index] = token;
    }
    if (!token.alias) {
      token.alias = token.label;
      var multiTokenSplitted = token.alias.split(" ");
      this.props.singleTokens.forEach((singleToken) => {
        if (singleToken.label === multiTokenSplitted[0] || singleToken.label === multiTokenSplitted[1]) {
          token.composedWith.push(JSON.parse(JSON.stringify(singleToken)));
        }
      });
    }
    this.props.onUpdateMultiTokens(tokens);
  }
}
const mapStateToProps = createSelector(
  state => state.multiTokens,
  state => state.singleTokens,
  state => state.classification,
  state => state.report,
  state => state.export,
  (multiTokens, singleTokens, classification, report, ex) => ({
    multiTokens,
    report,
    singleTokens,
    classification,
    ex,
  })
);
const mapActionsToProps = {
  onGetCompleteness: getCompleteness,
  onUpdateMultiTokens: updateMultiTokens,
  onUpdateVocab: updateVocab,
  onExportOutput: exportOutput
};
export default connect(
  mapStateToProps,
  mapActionsToProps
)(MultiWord);
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Alert.html">Alert</a></li><li><a href="Button.html">Button</a></li><li><a href="Classification.html">Classification</a></li><li><a href="ClassificationTag.html">ClassificationTag</a></li><li><a href="DashBoard.html">DashBoard</a></li><li><a href="Dashboard_.html">Dashboard</a></li><li><a href="DashboardRedirect.html">DashboardRedirect</a></li><li><a href="DashboardSidebar.html">DashboardSidebar</a></li><li><a href="DragAndDrop.html">DragAndDrop</a></li><li><a href="DynamicSlider.html">DynamicSlider</a></li><li><a href="Error.html">Error</a></li><li><a href="Export.html">Export</a></li><li><a href="Header.html">Header</a></li><li><a href="Headers.html">Headers</a></li><li><a href="HomeComponent.html">HomeComponent</a></li><li><a href="MultiWord.html">MultiWord</a></li><li><a href="NavBar.html">NavBar</a></li><li><a href="OverviewHeader.html">OverviewHeader</a></li><li><a href="Pattern.html">Pattern</a></li><li><a href="Report.html">Report</a></li><li><a href="Router.html">Router</a></li><li><a href="Sidebar.html">Sidebar</a></li><li><a href="Similarity.html">Similarity</a></li><li><a href="SingleRedirect.html">SingleRedirect</a></li><li><a href="SingleWord.html">SingleWord</a></li><li><a href="Slider.html">Slider</a></li><li><a href="TagButton.html">TagButton</a></li><li><a href="TaggingTool.html">TaggingTool</a></li><li><a href="Title.html">Title</a></li><li><a href="TokensNumber.html">TokensNumber</a></li><li><a href="Upload.html">Upload</a></li><li><a href="UploadRedirect.html">UploadRedirect</a></li></ul><h3>Global</h3><ul><li><a href="global.html#routes">routes</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.5</a> on Wed Feb 03 2021 16:06:41 GMT-0500 (Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
